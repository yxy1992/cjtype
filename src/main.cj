package cjtype
import std.fs.*
import std.io.*
import std.math.*
import std.binary.*
const VERSION=0.1//ç‰ˆæœ¬å·
//é”™è¯¯ä»£ç 
const ok:Int8=1//æ–‡ä»¶å­˜åœ¨
const dzcw:Int8=1//æ–‡ä»¶ä¸å­˜åœ¨
const wjcw:Int8=2//æ–‡ä»¶éå­—ä½“æ–‡ä»¶
const utfzfcw="3"//UTF-8å­—ç¬¦æ£€éªŒé”™è¯¯
const fz2z16cw="x"//UTF-8å­—ç¬¦ç¼–ç é”™è¯¯

class cjtype 
{
var ztlj=Path("")
//åˆ¤æ–­æ–‡ä»¶åœ°å€åŠå†…å®¹æ˜¯å¦æ­£ç¡®
func wjdq(link:String):Int8
{
//åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if(!exists(link)){return dzcw}
//åˆ¤æ–­æ–‡ä»¶æ˜¯å¦ä¸ºå­—ä½“æ–‡ä»¶
if(istype(link)!=ok){return wjcw}
ztlj=Path(link)
return ok
}
}

/////////////è¾…åŠ©ä»£ç //////////////////////
//ç®€å•æ ¡éªŒ
    func istype(link:String):Int8
    {
    var wj=File(link, OpenOption.Open(true,false))//æ‰“å¼€æ–‡ä»¶
    wj.seek(SeekPosition.Begin(0))//è®¾ç½®æ–‡ä»¶è¯»å–ä½ç½®
    var zf:Array<Byte>=Array<Byte>(4, repeat: 0)//åˆå§‹åŒ–4ä¸ªæ•°ç»„æˆå‘˜,å¹¶å¡«å……0
    wj.read(zf)//è¯»å–å¹¶å¡«å……åˆ°æ•°ç»„
    //æ–‡ä»¶å¤´æ ¡éªŒ
    if(zf!=[0,1,0,0]){return wjcw}
    return ok
    }
////å­—ç¬¦è½¬unicode 
 func Zfzunm(zf:String):String
    {
    var a=zf.toArray()
    var jz2=Array<Int8>(32,repeat:0)
    var ls:Float16=0.0
    ///UTF-8è½¬æ¢ä¸ºäºŒè¿›åˆ¶
    println(a)
    println(a.size)
    for(js in 1..a.size+1)
    {
    ls=Float16(a[js-1])/2.0
    
    for(i in 1..9)
    {
        
   if(ls-trunc(ls)>0.0)
   {
    jz2[js*8-i]=1
   }
   else
   {
    jz2[js*8-i]=0
   }
   ls=trunc(ls)/2.0
   
    }
    } 
    println(jz2)
    ///æˆªå–ç»„åˆè½¬æ¢Unicode
    println(a.size)
   match (a.size) {
    case 1 => return fz2z16(jz2[0].toString()+jz2[1].toString()+jz2[2].toString()+jz2[3].toString())+fz2z16(jz2[4].toString()+jz2[5].toString()+jz2[6].toString()+jz2[7].toString())

    case 2 => 
    let a=fz2z16(jz2[0].toString()+jz2[1].toString()+jz2[2].toString()+jz2[3].toString())
    let b=fz2z16(jz2[4].toString()+jz2[5].toString()+jz2[6].toString()+jz2[7].toString())

    return a+b

    case 3 => return fz2z16(jz2[4].toString()+jz2[5].toString()+jz2[6].toString()+jz2[7].toString())+fz2z16(jz2[10].toString()+jz2[11].toString()+jz2[12].toString()+jz2[13].toString())+fz2z16(jz2[14].toString()+jz2[15].toString()+jz2[18].toString()+jz2[19].toString())+fz2z16(jz2[20].toString()+jz2[21].toString()+jz2[22].toString()+jz2[23].toString())

    case 4 => return fz2z16(jz2[0].toString()+jz2[1].toString()+jz2[2].toString()+jz2[3].toString())
    case _ => return ""
   }
    }

//////2è½¬16è¿›åˆ¶è¾…åŠ©
    func fz2z16(a:String):String {
    match (a) 
    {
    case "0000" => return "0"
    case "0001" => return "1"
    case "0010" => return "2"
    case "0011" => return "3"
    case "0100" => return "4"
    case "0101" => return "5"
    case "0110" => return "6"
    case "0111" => return "7"
    case "1000" => return "8"
    case "1001" => return "9"
    case "1010" => return "A"
    case "1011" => return "B"
    case "1100" => return "C"
    case "1101" => return "D"
    case "1110" => return "E"
    case "1111" => return "F"
    case _ => return fz2z16cw          
    }
    }
///////////////////ä»£ç æµ‹è¯•/////////////////////////////
main(): Int64 {
    var zt=cjtype()
    
    zt.wjdq("./MiSans-Medium.ttf")
    println(169>>6)
    //println(Zfzunm("A"))
   //println(Zfzunm("*"))
    println(Zfzunm("Ã©"))

  // println(Zfzunm("ä¸­"))

   //println(Zfzunm("ğŸ‰"))
   
    
    return 0
}